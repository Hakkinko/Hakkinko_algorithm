/*快速排序是一种划分交换排序，采用了一种分治的策略。
（1） 分治法的基本思想
    　分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。
（2）快速排序的基本思想
    　设当前待排序的无序区为R[low..high]，利用分治法可将快速排序的基本思想描述为：
  分解： 
    　在R[low..high]中任选一个记录作为基准(Pivot)，以此基准将当前无序区划分为左、右两个较小的子区间R[low..pivotpos-1)和R[pivotpos+1..high]，并使左边子区间中所有记录的关键字均小于等于基准记录(不妨记为pivot)的关键字pivot.key，右边的子区间中所有记录的关键字均大于等于pivot.key，而基准记录pivot则位于正确的位置(pivotpos)上，它无须参加后续的排序。
      其中，划分的关键是要求出基准记录所在的位置pivotpos。划分的结果可以简单地表示为(注意pivot=R[pivotpos])：
                　R[low..pivotpos-1].keys≤R[pivotpos].key≤R[pivotpos+1..high].keys
                                其中low≤pivotpos≤high。
  求解： 
   　 通过递归调用快速排序对左、右子区间R[low..pivotpos-1]和R[pivotpos+1..high]快速排序。
  组合： 
    　因为当"求解"步骤中的两个递归调用结束时，其左、右两个子区间已有序。对快速排序而言，"组合"步骤无须做什么，可看作是空操作。
 */

//从小到大排序
void quickSort(int begin, int end, vector<int>& arr)
{
	if(begin >= end)
		return;
	int i, j, pivot, temp;
	i = begin, j = end;
	pivot = arr[begin];  //取第一个数为基准数
	while (i < j)
	{
		while (arr[j] >= pivot && i < j)
			j--;
		while (arr[i] <= pivot && i < j)
			i++;
		if(i < j)
		{
			temp = arr[i];
			arr[i] = arr[j];
			arr[j] = temp;
		}
	}
	//基准数归位
	arr[begin] = arr[i];
	arr[i] = pivot;
	quickSort(begin, i - 1, arr);//递归左边
	quickSort(i + 1, end, arr);//递归右边
}
